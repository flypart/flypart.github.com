---
layout: post
title: "【翻译】线性的重要性"
description: ""
category: 
tags: []
---
{% include JB/setup %}

这是很久之前翻译的GPUgem3的一篇文章。文章地址是：
[http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html "gpugems3_ch24")

当初翻译这篇文章，是因为在开发引擎的过程中，发现光照总是不如别人的引擎真实。于是为了加深对此问题的理解，特地搜集了一些资料进行阅读。调研过后，选了这篇翻译，给了组内的前辈和同事们，在此问题上形成了共识。最后Gamma校正虽然暂时没有加入到引擎中，但却提高了我对此问题的认识。在日后实现某些算法（例如真实感的皮肤渲染）的时候，少走了很多弯路。

翻译完之后没多久，自己又买了GPUgems3的中文版，发现人家翻译的也还不错。现在我斗胆把自己的拙作发出来，一是为了练习一下markdown的语法，二是因为我的遣词造句与别人还是有些区别的，如果有对原文不是很理解的朋友，也许可以参考我的描述，说不定能起到一点帮助作用。不过还是希望大家能去购买原书的正版，支持一下译者的劳动：）

这篇翻译我没做任何个人发挥，基本是逐字翻译，有错误的地方还望大家指正！谢谢！


# 线性的重要性 #

*Larry Gritz， NVIDIA Corporation*

*Eugene d'Eon，NVIDIA Corporation*

## 简介 ##
当代GPU具有很高的性能和高度的可编程性，这使得我们可以实时进行非常具有真实性的光照和着色计算。但是，当前几乎所有用来获取或者显示数字图像的设备都具有一个很微妙、很容易被忽略的特性，即所谓的“非线性”。为了正确进行光照计算和显示图像，有必要对纹理和帧缓存（Frame Buffer或者Render Target）做仔细的处理。正确的Gamma校正应该是解决这一问题最简单、最廉价、以及最被广泛采用的技术了。

## 光、显示器和色彩空间 ##

**数字图像获取、创建和显示的问题**

如果你对高质量渲染感兴趣，那么你可能问过这样一个问题：那些显示在CRT、LCD、电影或者纸上的图像，它们的发光模式与真实世界中那些物体的发光模式是一样的吗？是不是相似到了可以以假乱真的地步？理论上说，应该是这样的。但是你可能会惊讶地发现在数字图像创建的整个过程中，有好几个步骤都把事情搞复杂了。具体说来有如下几个问题：



- 我们把现实世界的光线捕捉下来生成数字图像（通过摄像机、扫描仪等设备），这些数字图像中每个像素的数值是不是准确表现了它所捕捉的光线的强度？如果射到这个像素的光子数目增大了一倍，那么这个像素的数值是不是也增大一倍？

- 我们用一个渲染器生成了一幅图像，这幅图像上一个像素的值是不是与我们的虚拟场景中的光线射进这个像素的光的强度成正比？

- 显示器是不是准确地把数字图像中一个像素的数值转换为光的亮度，再显示给你看？如果一个像素的数值翻倍了，那么显示器（CRT、LCD或者别的什么设备）发出的光的亮度也会翻倍吗？

出人意料的是，这些问题的答案很可能都是否定的。不论是图像的获取（扫描仪、绘图板、数码相机）还是图像的显示（CRT、LCD或者别的什么），都很可能不是线性的过程，它们的值与实际光的强度都不是成比例的。如果不仔细处理好这两个步骤，那么最终会渲染出不正确和不真实的图像。

“非线性”是一个很微妙的问题，人们常常会自觉或不自觉地将忽略掉它，在实时计算机图形学中尤其如此。然而，它在渲染过程中——特别是在那些含有大量高动态范围光照的场景中——所产生的错误结果却是显而易见的。如下图所示。

![](/image/gamma1.jpg)

【正确的gamma校正带来的好处。左图是正确的计算，右图是错误的。】

我们只需要采取几个简单的步骤即可解决这个问题，非常值得试一试。

**题外话：什么是线性？**

在数学中，线性变换指的是输入和输出的关系满足如下条件：

- 输入值先相加再进行变换所得到的结果，等于先进行变换之后再把结果相加。即f (x + y) = f (x) + f (y)。

- 先进行变换然后再进行缩放得到的结果，等于先缩放之后再进行变换。即f(k * x) = k * f (x). 

光的传递是线性的。两个光源对场景光照的效果是叠加起来的，它们之间不会相乘、相减或者相互干扰。

**显示器是非线性的，渲染器是线性的**

CRT显示器在把电压转换为亮度时并不是线性的。所有的LCD显示器虽然在物理上没有CRT的这一特性，但是为了模拟CRT的行为，也不是线性的。

显示器对电压的反馈接近于一条指数曲线，如下图。

![](/image/gamma2.jpg)

这里的指数就称作“gamma”。例如gamma为2.2时，一个有50%“强度”（即值为0.5）的像素发出的光的亮度，连“强度”为100%的像素所发出的光的亮度的1/4都不到（0.218）。这与我们直觉上的一半亮度是不同的。每个显示设备的gamma值都是不同的，但是一般都分布在2.0到2.4之间。为应对这种非线性效应而对数值进行调整就称作“gamma校正”。

注意到无论指数是多少，纯黑（0）和纯白（1）的值永远都不会变。只有0到1之间的那些值会被调整。

渲染器、着色器都在线性数据上进行操作。它们计算每个光源对像素的影响（光源强度乘以反射系数，反射系数来自常量值或者纹理采样），再把这些结果累加起来。

但这其中有两个隐含的假设，即一个纹理贴图上的像素的值应该正比与其反射系数的大小（线性关系）；同时，在显示器上观察者看到的光的强度应该正比于帧缓存中的像素的值（同样是线性关系）。

关键的一点是，如果输入是非线性的，那么渲染器或着色器的计算就会得到错误的结果。这当然会妨碍我们获得高真实感的图像。

考虑一幅数字图像。如果你在绘制它的时候不进行正确的gamma校正，那么这幅画就会包含隐性的非线性性质。在你的显示器上可能看来不错，但是到别的显示器上可能就完全不同了。如果一个渲染器读取了这幅画，并且假设这幅画是线性的，那么渲染的结果就会是错误的。如果把一个渲染器输出的线性结果直接输出到显示器上（不经过gamma校正），那么它会看起来过暗。这是也错误的结果，而且仅仅通过调高亮度是无法校正的。

如果你在图像渲染的两端都做错了，即绘制、采集和保存了在gamma空间的图像（非线性的），然后把它们当做线性的输入给渲染器，接着在线性空间进行光照计算，最后又不经过gamma校正把结果还原到非线性空间就输出到了显示器，那么结果乍一看可能还不错。为什么呢？因为“非线性”的采集和“非线性”的显示在一定程度上相互抵消了。但是这样结果显然依旧是不正确的。这样在渲染的过程中还是会出现种种瑕疵，例如：非线性的输入在光照计算之后会改变颜色、alpha通道会错误、mipmap过滤缩放也会错误等。此外，进行真实感光照（例如高动态范围光或者基于图像的光照）也不会如你所愿的正常进行。

并且，渲染的结果在每个人的显示器上看起来也会不同。因为输入图像的制作和渲染结果的输出很可能是分别在不同的显示器上进行的，而图像看起来的样子在本质上是与显示器紧密相关的。

## 错误症状 ##

如果你没有处理好gamma校正——即在非线性空间进行了光照计算，那么你很可能会遇到下述的问题。

**非线性的输入纹理**

一般用户的显示器都是没有经过校准的（非线性的），而且他们也没听过所谓的gamma校正。因此在实际中，很多美术材料都预先进行过校正了。例如，所有的JPEG文件都预先用gamma 2.2进行了校正。并不是所有显示器的gamma都是2.2，但是也差不了多少，所以图像在绝大部分显示器上看起来都不错。这意味着JPEG图像（包括扫描或者用摄像机拍摄得到的）是非线性的，所以它们不能被当做线性的纹理输入而直接传给shader。

预先校正的图像格式非常便于直接显示在LCD或者CRT显示器上面。并且在存成每通道8bit图像时可以将更多的色彩数目分配给较暗的区域，而人眼对这些区域的色彩变化也更加敏感。但是这样一来这种格式的图像在参与光照计算之前必须经过预处理。

**MipMaps**

当创建mipmap时，每生成新的一层mipmap都需要对前一层mipmap进行缩小。最普遍的做法是取相邻2x2个像素的值，相加再除以4得到新一层mipmap的值。假设在高分辨的这一层mipmap上有一条图像的边界，其中两个像素的值是0，另外两个像素的值是1，那么新产生的mipmap上像素的值应该是0.5，对吧？亮度的一半，因为它有一半是全黑的，还有一半是全白的。在线性环境下的确是这样。但是如果这张纹理上的像素的值都是经过了gamma校正的，是非线性的，那么会怎样呢？假设gamma值是2，那么新产生的这个值为0.5的像素它实际显示出来只有全白亮度的25%。这样在较小的mipmap上就会产生一些扎眼的错误，因为过滤后的值并不是之前亮度的平均值。经过渲染后的物体的亮度会随着边界轮廓而改变，也会随着距离摄像机的距离而改变。

**光照**

考虑对一个简单的Lambertian材质的圆球进行光照。如下图所示。

![](/image/gamma3.jpg)

如果反射光的强度与N*L成正比，那么在N与L成60°夹角的位置的一个点A，它的亮度应该是正好是最大亮度的一半，即，它的亮度应该是某一个正对着光源的点B的亮度的一半（即图中最右端的点）。如果A值被转换到了线性空间输出，那么A点的亮度应该与现实中的一摸一样。但是如果你把A转换到了gamma空间输出，如果gamma值是2.2的话， 那么输出的值就是0.5^2.2，大约是B点亮度的四分之一。

换句话说，如果渲染器假定输入是线性的数据，但是输出在一个非线性显示器上，那么计算机中的材质和光源与现实中的材质和光源看起来会有差异，即使你设置的参数是与现实中一致的。总的说来，场景会看起来比正确的更加模糊和暗淡（如上图b）。然而，仅仅稍微提高画面的亮度并不能解决问题，高亮度的部分会比低中等亮度的部分被校正更多。与现实世界相比，阴影的边界和亮度的转换会变得更加尖锐，从光亮部分转换到黑暗部分会更快。而角落部分会看起来过于的暗。

在渲染中用的高端的技术越多（诸如HDR、全局光照、次表面散射），对线性空间光照计算的依赖就越严重。

**负负并不得正**

最常见的错误就是采用非线性的颜色纹理做光照计算，然后不经过gamma校正就进行输出。两次错误比一次错误更加难以被发现，因为两次校正干的事情大致上是相反的，一次让画面变亮了，而另一次让画面变暗了。然而，这造成了很多问题，并且这些问题都是很容易避免的。

下图显示了两幅图片的对比，都是采用同样的shader实时渲染真实性的皮肤。

![](/image/gamma4.jpg)

皮肤的纹理图片来自于JPEG格式的图像，左图将漫反射纹理转换到了线性空间。光照（包括次表面散射）和着色都得到了正确的计算，并且最终图像也经过了gamma校正，在大部分非线性显示器上都可以正确显示。
右图则两次校正都没有进行，好几个问题都表现了出来。皮肤的颜色来自彩色照片，渲染后的色调改变了，因为光照是在非线性空间进行的。光的照射会改变像素的色彩值，它们只应该变暗或变亮，但是现在它们的颜色却不经意地被改变了。皮肤纹理中的红色分量比绿色和蓝色分量都要大，因此随着明暗变化，三个分量的变化程度就不成比例了。本来应该是白色的高光，当叠加上了漫反射之后，变得偏黄。阴影区域变得非常暗。而次表面散射则变得几乎不可见了（特别是红色渗透到阴影区域的部分，对比鼻子下方的阴影），因为这部分的色彩在显示的时候被gamma校正压下去了。

在非线性环境下调整光照是一个问题。如果我们不改变上图的模型参数而只是增加光源的强度，非线性光照计算变得更悲剧了。

![](/image/gamma5.jpg)

可以总结出一条经验：如果色调随着光的强度发生变化，那么这很可能是是由于非线性空间的光照计算。这时必须要引入gamma校正。

如果忽略了gamma校正，那么在渲染次表面散射效果时会遇到一个普遍的问题，那就是在阴影边缘会出现蓝绿色的光晕，皮肤看起来像是蜡像。如下图所示。

![](/image/gamma6.jpg)

当你调整散射参数试图让红色渗透到阴影中的时候，问题就来了。由于在非线性空间下这一效果很难被实现，那么你很可能会对红色分量进行一个很大的模糊。结果就造成了在明亮区域扩散过多（看起来像蜡像），并且使得阴影边缘的红色变暗太多（一圈蓝绿光晕）。

## 解决方案 ##

gamma校正所做的事情就是在图像显示出来之前对其像素值进行一个变换，该变换与显示器所做的变换正好相反。也就是说，如果我们把像素值变为了1 / Gamma次方，那么显示器还会将其提高到Gamma次方，正好两者抵消，结果也就使输出变为了线性的。

通常的实现方法是让操作系统应用一个色彩校正“查找表”（LUTs），把gamma校正包含在其中。这样的调整使得所有的渲染、合成或者别的图像操作都在线性空间进行，并且让所有线性地扫描、绘制或者渲染的图像能够正确显示。

动画或者视觉效果工作室以及商业出版社都会非常细心地处理这一过程。这一工作常常由一个专门的员工来负责，由他来对显示器、图像合成管线、电影和视频扫描以及最终输出的结果进行色彩管理。实际上，对于高端应用而言，简单的色彩管理是不够的。合成师们常常要使用更加复杂的一个3D色彩查找表来进行校正，这张色彩查找表是针对某类特定的显示器或者底片材料进行精确度量而生成的。相比于动画和电影界，游戏界的开发者们往往采用了错误的过程，结果产生了前述的种种错误。这也是为什么绝大部分（不是全部）的电影看起来比游戏好上很多的原因之一，而这一原因与多边形数目、着色算法或者艺术家的技巧都毫无关系。有些电影看起来很糟糕很可能也是因为他们的调色板或者gamma设置错了。

玩家不可能拥有一个校准到标准的线性显示器。我们也不可能知道适合于他的显示器的色彩校正表。而且无论如何玩家都不会想一个全局的gamma校正用的色彩校正表应用在整个显示器上。为什么呢？因为一旦这么做的话，那么他们系统中那些通过web浏览器看到的JPEG文件就会整个被“漂白”了（因为我们额外为显示器设置了一个全局的色彩校正表，最终相当于对JPEG文件做了两次校正），而他显然会感到大惑不解（电影工作室的员工不会为此而烦恼，因为他们知道原因是什么。只要在最后输出到荧幕上的电影是正确的就行了）。但是用一个适用于大部分显示器的所谓的“平均”的gamma校正就可以给我们一个不错的解决方案。本章节剩下的部分将会对此进行讨论。

**输入图像**（通过扫描、PS或者数码相机）

所有通过扫描或者数码相机采集的图像都可能已经做过gamma校正了（特别是如果存成了JPEG格式的话）并且存储在了非线性空间。如果你直接在电脑上绘制了一幅纹理，并且没有设置gamma色彩校正表，那么这些图像也会被表示在显示器的色彩空间中。如果一个图像通过web浏览器打开看起来是正确的，那么它有可能就是已经经过了gamma校正，即不是线性的。

任何已经被gamma校正过的纹理在输入到着色器或者合成器之前都必须被还原到线性的色彩空间中。而且你只需要把这一校正应用于那些会参与到线性光照计算的纹理上。色彩值（例如光的强度和漫反射的顶点颜色）应该是不需要校正的。Alpha通道、法线图、displacement map中的值等几乎都肯定已经是线性的，所以不要再校正了。此外如果有的输入纹理是刻意地保存在线性空间下的，那么当然也不要校正。

所有的现代的GPU都支持sRGB这类纹理格式。标记了这一格式的纹理在被采样的时候，GPU会自动将其值进行gamma校正，然后把线性的颜色值返回。在NV Geforce8系列之后的硬件上，所有对纹理进行的采样都会在过滤之前先进行gamma校正，以确保过滤是在线性空间进行的（老一点的GPU会在过滤完成之后再进行gamma校正）。这一校正基于IEC标准进行，基本上与Gamma设为2.2时候的曲线是一致的。在不知道显示器的确切gamma值的情况下，用这一方法进行校正是一个安全的选择。如果纹理中含有alpha通道，那么alpha通道是不会进行校正的。

在OpenGL和DirectX中都对所有的8-bit纹理格式定义了对应的sRGB格式。例如，在调用glTexImage2D时，传入GL_SRGB_EXT而非GL_RGB就可以保证返回值是线性的。

通过sRGB进行自动的色彩校正不用付出什么代价，它比每次采样纹理之后再进行手工的gamma校正要更好。因为每个pow指令都会被展开成两条指令，并且手动的校正发生在过滤之后，而这时过滤就只能在非线性空间进行的了。预先把纹理转换到线性空间然后再载入到渲染器也不是个好主意。把线性空间的像素值存入一个8bit深度的图像文件将会丢失低亮度部分的细节，当把这样的数据输入渲染器进行计算并且最后转换回非线性空间时，将会在暗部会产生光带状的走样。
手动把颜色转换到线性空间的代码：
Float3 diffuseCol = pow(tex2D(diffTex, texCoord), 2.2);
或者（速度更快，但是假定gamma是2）：
Float3 diffuseCol = tex2D(diffTex, texCoord);
diffuseCol = diffuseCol * diffuseCol;

有的纹理输入是线性的而有的不是，对于引擎程序员而言管理它们可能是一件繁琐的事情。在很多情况下最简单的方案还是在进入渲染之前就将它们转换到线性空间。但这也会带来前述的问题。

**输出图像**

最后一步是在显示图像之前对像素值进行gamma校正，这样他们在非线性显示器上显示的图像才是正确的。指定一个用sRGB标注的帧缓存可以将这个工作完全丢给GPU，也不再需要改变任何shader代码。所有shader返回的值在存入帧缓存之前都会自动进行gamma校正。更进一步，在Geforce8系列或者之后的硬件上，如果开启了alpha混合，那么之前存入的值在参与混合之前还会被转换回线性空间，之后再被转换到非线性空间存入。当开启了sRGB时，alpha值不会gamma校正。如果硬件不支持sRGB缓存，你可以使用耗费稍大的解决方案，通过自己写shader来实现。然而，这样所有的alpha混合就可能不正确了。
float3 finalCol = do_all_lighting_and_shading();   
float pixelAlpha = compute_pixel_alpha();   
return float4(pow(finalCol, 1.0 / 2.2), pixelAlpha);   
或者效率更高的算法，假定gamma为2
 return float4( sqrt( finalCol ), pixelAlpha );  

**作为中间结果的帧缓存**

有些小地方值得注意。如果需要对图像进行后处理操作，那么你应该在后处理处理完之后的最后一步才做gamma校正。不要先渲染，再校正，然后再在非线性的图像上做进一步的数学计算。

同样，如果你在渲染到纹理，那么你有两个选择：1，做gamma校正，在之后都把这个纹理当做非线性纹理进行处理；2，不做gamma校正，在之后都把这个纹理当做线性纹理进行处理。作为中间结果的帧缓存如果仅用8bit的精度进行存储，那么线性存储的情况会比非线性存储的情况丢失一些精度（在暗处产生条带）。因此，采用16bit的浮点纹理或者用sRGB格式标注的纹理更好。

## 结论 ##

OpenGL、DirectX以及你写的任何shader在做数学计算时都假定你输入的任何纹理、光源、材质或者输出是线性的。但是实际上作为输入的纹理很可能是非线性的，而且用户的显示器十有八九没有经过校准而且会附加一个变换将颜色变换到非线性空间。这样将导致各种走样和不准确的计算结果，有一些很细微（例如mipmap的过滤错误），有些则很显眼（例如不正确的亮度衰减）。

我们强烈建议开发者采用如下简单的步骤消除这些问题：

- 假定所有的玩家都在使用未经校准的非线性显示器，并且这些显示器对输入值的响应接近于gamma = 2.2的这样一个曲线。为了让用户有更好的体验，可以在游戏中提供给用户gamma校正表和相应的界面，让用户自己选择一个合适的gamma值。

- 当从非线性纹理中读取值（这些值在未经校准的非线性显示器上看起来是对的）作为光或者颜色值的时候，将取到的值做一个pow gamma操作，把它们变为线性空间的值来参与之后的shader计算。不要对已经是线性空间的值做这一变换（例如某些hdr光照图、法线图、高度图或者别的非色彩数据）。尽可能使用sRGB格式的纹理，这样可以提高效率并且让过滤变得正确（在Geforce8以上的硬件中）。

- 在所有计算的最后，对像素颜色值进行一个pow 1/gamma操作。采用sRGB格式的帧缓存扩展可以高效地自动进行这一校正，并且alpha也会是正确的。

仔细地按照这些步骤进行对提高游戏的画面效果是至关重要的，特别是这样也可以提高光照和材质计算的正确性。


